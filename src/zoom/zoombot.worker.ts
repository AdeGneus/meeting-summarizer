import { parentPort } from "worker_threads";
import puppeteer from "puppeteer";
import { exec } from "child_process";
import logger from "../common/utils/logger";
import { ZoomService } from "../services/zoom.service";

// Path to the FFmpeg binary
const ffmpegPath = "/usr/bin/ffmpeg"; // Adjust if needed

const botName = "Tom Meeting Summarizer";
const zoomService = new ZoomService();

parentPort?.on("message", async (workerData: { inviteLink: string }) => {
  try {
    const { inviteLink } = workerData;
    if (!inviteLink) {
      throw new Error("Invalid Zoom invite link received.");
    }

    logger.info(`üîπ Fetching Join URL from Invite Link: ${inviteLink}`);

    const { meetingId, passcode } = await zoomService.getMeetingIdAndPasscode(
      inviteLink
    );
    if (!meetingId) {
      throw new Error("Failed to extract the meeting ID from the invite link.");
    }

    if (!passcode) {
      throw new Error("Passcode is required");
    }

    const webClientUrl = `https://zoom.us/wc/${meetingId}/join`;
    logger.info(`üîπ Bot Joining via Web Client URL: ${webClientUrl}`);

    // Run Xvfb for a virtual display
    exec("Xvfb :99 -screen 0 1280x1024x24 &", () => {
      process.env.DISPLAY = ":99"; // Set environment variable for Puppeteer
    });

    // Launch Puppeteer to interact with Zoom
    const browser = await puppeteer.launch({
      headless: true,
      args: [
        "--no-sandbox",
        "--disable-setuid-sandbox",
        "--use-fake-ui-for-media-stream", // Handle media stream in headless mode
      ],
    });

    const page = await browser.newPage();
    await page.goto(webClientUrl, { waitUntil: "networkidle2" });
    logger.info("‚úÖ Loaded Join Page!");

    await joinMeeting(page, passcode);

    // Start recording the meeting's audio using FFmpeg
    startAudioRecording();

    // Handle meeting end or bot leaving logic here
    await waitForMeetingToEnd(page);
    await browser.close();
    logger.info("‚úÖ Bot Left the Meeting!");

    // After the meeting ends, stop the recording and transcribe it
    stopAudioRecording();
    await transcribeAudio("output.mp3"); // Audio file generated by FFmpeg
  } catch (error: any) {
    logger.error("‚ùå Failed to join and listen:", error);
    parentPort?.postMessage({ success: false, error: error.message });
  }
});

async function joinMeeting(page: any, passcode?: string) {
  await page.waitForSelector("#input-for-name");
  await page.waitForSelector("#input-for-pwd");
  await page.type("#input-for-name", botName);

  if (passcode) {
    await page.type("#input-for-pwd", passcode);
  }

  const joinButtonSelector = ".zm-btn.preview-join-button";
  await page.waitForSelector(joinButtonSelector);
  await page.click(joinButtonSelector);
  logger.info("‚úÖ Bot Submitted Name and Passcode!");
}

async function waitForMeetingToEnd(page: any) {
  const meetingEndedSelector = ".zoom-meeting-ended";

  try {
    await page.waitForSelector(meetingEndedSelector, { timeout: 60000 });
    logger.info("‚ùå Meeting has ended. Bot is leaving the meeting.");
  } catch (e) {
    logger.info("‚è≥ Meeting still active... Bot is staying in the meeting.");
  }
}

// Start audio recording using FFmpeg (or another recording tool like OBS)
function startAudioRecording() {
  const recordingCommand = `${ffmpegPath} -f pulse -i virtual_sink.monitor -t 3600 -acodec mp3 output.mp3`; // Record audio for 1 hour
  exec(recordingCommand, (error, stdout, stderr) => {
    if (error) {
      logger.error(`‚ùå Error starting audio recording: ${error}`);
      return;
    }
    logger.info("‚úÖ Audio recording started.");
  });
}

// Stop audio recording
function stopAudioRecording() {
  exec("pkill ffmpeg", (error, stdout, stderr) => {
    if (error) {
      logger.error(`‚ùå Error stopping audio recording: ${error}`);
      return;
    }
    logger.info("‚úÖ Audio recording stopped.");
  });
}

// Transcribe audio using Whisper
async function transcribeAudio(audioFilePath: string) {
  const { exec } = require("child_process");
  const transcriptionCommand = `whisper ${audioFilePath} --model large --output_format txt`;

  exec(transcriptionCommand, (error: any, stdout: any, stderr: any) => {
    if (error) {
      logger.error(`‚ùå Error during transcription: ${error}`);
      return;
    }
    const transcription = stdout;
    logger.info("‚úÖ Transcription complete!");
    parentPort?.postMessage({
      success: true,
      transcription: transcription,
    });
  });
}
